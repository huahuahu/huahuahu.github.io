<h1 id="sqlite索引的原理">sqlite索引的原理</h1>
<h2 id="一引言">一、引言</h2>

<p><a href="http://www.cnblogs.com/lyroge/p/3837886.html">这篇文章</a>，里面讲到对于一个41G大小、包含百万条记录的数据库进行查询操作，如果利用了索引，可以把操作耗时从37s降到0.2s。
那么什么是索引呢？利用索引可以加快数据库查询操作的原理是什么呢？</p>
<h2 id="二索引的基本原理">二、索引的基本原理</h2>

<p>数据库提供了一种持久化的数据存储方式，从数据库中查询数据库是一个基本的操作，查询操作的效率是很重要的。
对于查询操作来说，如果被查询的数据已某种方式组织起来，那么查询操作的效率会极大提高。
在数据库中，一条记录会有很多列。如果把这些记录按照列Col1以某种数据结构组织起来，那么列Col2一定是乱序的。
因此，数据库在原始数据之外，维护了满足特定查找算法的数据结构，指向原始数据，称之为<strong>索引</strong>。
举例来说，在下面的图中，数据库有两列Col1、Col2。在存储时，按照列Col1组织各行，比如Col1已二叉树方式组织。如果查找col1中的某一个值，利用二叉树进行二分查找，不需要遍历整个数据库。
这样一来列Col2就是乱序的。为了解决这个问题，为Col2建立了索引，即把Col2也按照某种数据结构（这里是二叉树）组织起来。这样子查找列Col2时只需要进行二分查找即可。
<img src="http://oda58fqub.bkt.clouddn.com/14808584745554.jpg" alt="" /></p>

<h2 id="三索引的实现">三、索引的实现</h2>
<p>由于数据库是存储在磁盘上的，因此实现索引用的数据结构会存储在磁盘上。磁盘的IO是需要注意的问题。</p>

<ol>
  <li>二叉树<br />
二叉树是一种经典的数据结构，但是并不适合进行数据库索引。<br />
原因在于二叉树中每一个节点的度只有2，树的深度较高。在存储时，一般一个节点需要一次磁盘IO，树的深度较高，查询一个数据需要的磁盘IO次数越高，查找需要的时间越长。</li>
  <li>B树
B树是二叉树的变种，主要区别在于每一个节点的度可以大于2，即每一个节点可以分很多叉，大大降低了树的深度。
<img src="http://oda58fqub.bkt.clouddn.com/14824192651928.jpg" alt="" />
    <ul>
      <li>每条数据表示为[key,data]</li>
      <li>每个非叶子节点有(n-1)条数据n个指针组成</li>
      <li>所有叶节点具有相同的深度，等于树高h</li>
      <li>指针指向节点的key大于左边的记录小于右边记录</li>
    </ul>

    <p>上面这些特点使得B+树的深度大大降低，并且实现了对数据的有序组织。</p>
  </li>
  <li>B+树<br />
B+树是对B树的扩展，特点在于非叶子节点不存储data，只存储key。如果每一个节点的大小固定（如4k，正如在sqlite中那样），那么可以进一步提高内部节点的度，降低树的深度。
<img src="http://oda58fqub.bkt.clouddn.com/14824195985751.jpg" alt="" />
    <ul>
      <li>非叶子节点只存储key，叶子节点不存储指针</li>
      <li>每一个节点大小固定，需要一次读磁盘操作（page）</li>
    </ul>
  </li>
  <li>顺序访问指针的B+树<br />
对B+树做了一点改变，每一个叶子节点增加一个指向相邻叶子节点的指针，这样子可以提高区间访问的性能。
<img src="http://oda58fqub.bkt.clouddn.com/14824200088734.jpg" alt="" />
如图，访问key在15到30的data。
    <ul>
      <li>如果没有水平的指针  <br />
 B+树查找找到key=15的data，在同一个块中找到key=18的data。然后进行第二次B+查找，找到key=20的data，在同一个块中找到key=30的data。</li>
      <li>有水平的指针<br />
 B+树查找找到key=15的data，查找同一个块的内容，或沿着水平指针依次向右遍历。</li>
    </ul>
  </li>
</ol>

<h2 id="四sqlite中数据存储方式">四、Sqlite中数据存储方式</h2>
<ul>
  <li>表(table)和索引(Index)都是带顺序访问指针的B+树</li>
  <li>table对应的B+树中，key是rowid，data是这一行其他列数据（sqlite为每一行分配了一个rowid）</li>
  <li>index对应的B+树种，key是需要索引的列，data是rowid</li>
</ul>

<p>根据索引查找数据时，分两步</p>

<ol>
  <li>根据索引找到rowid（第一次B+树查找）</li>
  <li>根据rowid查找其他列的数据（第二次B+树查找）</li>
</ol>

<p>通过两次B+树查找避免了一次全表扫描。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1. 对某一行或某几行添加PRIMARY KEY或UNIQUE约束，那么数据库会自动为这些列创建索引
2. 指定某一列为INTEGER PRIMARY KEY，那么这一列和rowid被指定为同一列。即可以通过rowid来获取，也可以通过列名来获取。
</code></pre>
</div>
<h3 id="五一个例子">五、一个例子</h3>
<p>下面是一个数据库中一个表的统计信息，通过<a href="https://sqlite.org/sqlanalyze.html">sqlite3_analyzer</a>工具得到。
<img src="http://oda58fqub.bkt.clouddn.com/14824209528139.jpg" alt="-w753" />
可以看到表中一共有3651条记录，B树的深度只有2，有33个叶子节点，1个非叶子节点。因此最多只需要2次磁盘IO就可以根据rowid找到一行的数据。</p>
<h2 id="六利用索引提高查找效率">六、利用索引提高查找效率</h2>
<p>比如我们有这么一个表<br />
<img src="http://oda58fqub.bkt.clouddn.com/14824213415023.jpg" alt="" /></p>

<ol>
  <li>
    <p>benchmark
查询语句如下</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>SELECT price FROM fruitsforsale WHERE fruit=‘Peach’
</code></pre>
    </div>
    <p>由于没有索引，因此不得不做一次全表扫描。通过顺序访问指针遍历各个记录(record)，比较fruit这一列和‘peatch’是否一致，如果一致，返回这一行的price列的值。<br />
<img src="http://oda58fqub.bkt.clouddn.com/14824214192659.jpg" alt="" /></p>
  </li>
  <li>对‘fruit’列加索引
如下，运行同样的语句，可以根据索引找到目标列对应的rowid为4，然后根据rowid找到对应行，从而选出price。通过两次B+树查找避免了全表查找。这也是最简单的情况<br />
<img src="http://oda58fqub.bkt.clouddn.com/14824216313501.jpg" alt="" /></li>
  <li>多条索引命中
建立索引时，不要求索引是uique的，即索引表中的key可以是一样的。
如下图，索引表中有<code class="highlighter-rouge">orange</code>两条记录，找到第一条记录时，根据顺序访问指针可以轻易找到下一条索引，避免另一次B+树查找。（rowid=1和rowid=23可能位于两个不同的叶子节点中）
即这个查找索引的过程，可以通过一次B+树查和一次next操作完成，而next操作是很快的。<br />
<img src="http://oda58fqub.bkt.clouddn.com/14824218349665.jpg" alt="" /></li>
  <li>
    <p>利用索引加快搜索和排序
在大多情况下，我们需要同时进行查找和排序操作，这时如果建立适当的索引，可以提高查找效率。
比如下面表中对fruit和state两列做了索引，运行下面的sql语句时，就不需要进行排序操作了，因为索引表是带有顺序的。</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>SELECT price FROM fruitforsale WHERE fruit='Orange' ORDER BY state
</code></pre>
    </div>
    <p><img src="http://oda58fqub.bkt.clouddn.com/14824220826728.jpg" alt="" /></p>
  </li>
</ol>

<h2 id="七解释引言中问题">七、解释引言中问题</h2>
<p>在sqlite中有一个命令叫做<code class="highlighter-rouge">explain query plan</code>，可以查看sqlite是如何执行查找操作的。下面的数据库语句不是引言中的查询语句，原理一样</p>

<ul>
  <li>
    <p>37s的操作（没有用索引)<br />
<img src="http://oda58fqub.bkt.clouddn.com/14824223446285.jpg" alt="" /></p>
  </li>
  <li>
    <p>0.2s的操作（用了索引）
<img src="http://oda58fqub.bkt.clouddn.com/14824223522361.jpg" alt="" /></p>
  </li>
</ul>

<p>注意detail列。不用索引时，使用的是“SCAN”这个词，即全表扫描。使用索引时，使用的是“SEARCH”这个词。
对于一个41G的表来说，进行全表扫描的代价显然是很大的。</p>

<h2 id="八参考链接">八、参考链接</h2>

<ol>
  <li><a href="http://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html">浅谈算法和数据结构: 十 平衡查找树之B树</a></li>
  <li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a></li>
  <li><a href="https://www.sqlite.org/queryplanner.html">Query Planning(这篇是sqlite关于索引的文档)</a></li>
  <li><a href="https://www.sqlite.org/eqp.html">EXPLAIN QUERY PLAN</a></li>
  <li><a href="http://www.cnblogs.com/lyroge/p/3837886.html">MySQL单表百万数据记录分页性能优化</a></li>
</ol>

